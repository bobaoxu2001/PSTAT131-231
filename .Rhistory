rand_tree_final <- finalize_workflow(boost_workflow, best3)
boost_fit <- fit(rand_tree_final, data = pokemon_test)
auc(pokemon_test$default, predicted)
library(pROC)
# pruned tree
best1 <- select_best(tune_res)
class_tree_final <- finalize_workflow(tree_workflow, best1)
class_tree_final_fit <- fit(class_tree_final, data = pokemon_test)
# random forest
best2 <- select_best(tune_res_forest)
rand_tree_final <- finalize_workflow(forest_workflow, best2)
rf_fit <- fit(rand_tree_final, data = pokemon_test)
# boosted tree
best3 <- select_best(tune_res_boost)
rand_tree_final <- finalize_workflow(boost_workflow, best3)
boost_fit <- fit(rand_tree_final, data = pokemon_test)
auc(pokemon_test$default, class_tree_final_fit)
library(pROC)
# pruned tree
best1 <- select_best(tune_res)
class_tree_final <- finalize_workflow(tree_workflow, best1)
class_tree_final_fit <- fit(class_tree_final, data = pokemon_test)
# random forest
best2 <- select_best(tune_res_forest)
rand_tree_final <- finalize_workflow(forest_workflow, best2)
rf_fit <- fit(rand_tree_final, data = pokemon_test)
# boosted tree
best3 <- select_best(tune_res_boost)
rand_tree_final <- finalize_workflow(boost_workflow, best3)
boost_fit <- fit(rand_tree_final, data = pokemon_test)
auc(pokemon_test, class_tree_final_fit)
library(pROC)
# pruned tree
best1 <- select_best(tune_res)
class_tree_final <- finalize_workflow(tree_workflow, best1)
class_tree_final_fit <- fit(class_tree_final, data = pokemon_test)
# random forest
best2 <- select_best(tune_res_forest)
rand_tree_final <- finalize_workflow(forest_workflow, best2)
rf_fit <- fit(rand_tree_final, data = pokemon_test)
# boosted tree
best3 <- select_best(tune_res_boost)
rand_tree_final <- finalize_workflow(boost_workflow, best3)
boost_fit <- fit(rand_tree_final, data = pokemon_test)
# auc values
# ROC curve
# roc_auc
deci_tree_fit <- augment(class_tree_final_fit,
new_data = pokemon_test,
type = "prob") %>%
mutate(type_1 = as.factor(type_1)) %>%
roc_auc(truth = type_1, .pred_Bug:.pred_Water)
rand_tree_fit <- augment(rf_fit,
new_data = pokemon_test,
type = "prob") %>%
mutate(type_1 = as.factor(type_1)) %>%
roc_auc(truth = type_1, .pred_Bug:.pred_Water)
boost_model_fit <- augment(boost_fit,
new_data = pokemon_test,
type = "prob") %>%
mutate(type_1 = as.factor(type_1)) %>%
roc_auc(truth = type_1, .pred_Bug:.pred_Water)
matrix_rocauc <- bind_rows("ROC_AUC for the Best pruned tree model"= deci_tree_fit,"ROC_AUC for the Best Random Forest model"=rand_tree_fit,"ROC_AUC for the Best Boosted model"=boost_model_fit,.id="model")
matrix_rocauc
library(pROC)
# pruned tree
best1 <- select_best(tune_res)
tree_final <- finalize_workflow(tree_workflow, best1)
tree_final_fit <- fit(tree_final, data = pokemon_test)
# random forest
best2 <- select_best(tune_res_forest)
rand_tree_final <- finalize_workflow(forest_workflow, best2)
rand_tree_final_fit <- fit(rand_tree_final, data = pokemon_test)
# boosted tree
best3 <- select_best(tune_res_boost)
boost <- finalize_workflow(boost_workflow, best3)
boost_fit <- fit(rand_tree_final, data = pokemon_test)
# auc values
# ROC curve
# roc_auc
deci_tree_fit <- augment(class_tree_final_fit,
data = pokemon_test,
type = "prob") %>%
mutate(type_1 = as.factor(type_1)) %>%
roc_auc(truth = type_1, .pred_Bug:.pred_Water)
library(pROC)
# pruned tree
best1 <- select_best(tune_res)
tree_final <- finalize_workflow(tree_workflow, best1)
tree_final_fit <- fit(tree_final, data = pokemon_test)
# random forest
best2 <- select_best(tune_res_forest)
rand_tree_final <- finalize_workflow(forest_workflow, best2)
rand_tree_final_fit <- fit(rand_tree_final, data = pokemon_test)
# boosted tree
best3 <- select_best(tune_res_boost)
boost <- finalize_workflow(boost_workflow, best3)
boost_fit <- fit(rand_tree_final, data = pokemon_test)
# auc values
# ROC curve
# roc_auc
deci_tree_fit <- augment(tree_final_fit,
data = pokemon_test,
type = "prob") %>%
mutate(type_1 = as.factor(type_1)) %>%
roc_auc(truth = type_1, .pred_Bug:.pred_Water)
library(pROC)
# pruned tree
best1 <- select_best(tune_res)
tree_final <- finalize_workflow(tree_workflow, best1)
tree_final_fit <- fit(class_tree_final, data = pokemon_test)
# random forest
best2 <- select_best(tune_res_forest)
rand_tree_final <- finalize_workflow(forest_workflow, best2)
rf_fit <- fit(rand_tree_final, data = pokemon_test)
# boosted tree
best3 <- select_best(tune_res_boost)
rand_tree_final <- finalize_workflow(boost_workflow, best3)
boost_fit <- fit(rand_tree_final, data = pokemon_test)
# auc values
# ROC curve
# roc_auc
deci_tree_fit <- augment(class_tree_final_fit,
data = pokemon_test,
type = "prob") %>%
mutate(type_1 = as.factor(type_1)) %>%
roc_auc(truth = type_1, .pred_Bug:.pred_Water)
library(pROC)
# pruned tree
best1 <- select_best(tune_res)
tree_final <- finalize_workflow(tree_workflow, best1)
tree_final_fit <- fit(class_tree_final, data = pokemon_test)
# random forest
best2 <- select_best(tune_res_forest)
rand_tree_final <- finalize_workflow(forest_workflow, best2)
rf_fit <- fit(rand_tree_final, data = pokemon_test)
# boosted tree
best3 <- select_best(tune_res_boost)
rand_tree_final <- finalize_workflow(boost_workflow, best3)
boost_fit <- fit(rand_tree_final, data = pokemon_test)
# auc values
# ROC curve
# roc_auc
deci_tree_fit <- augment(tree_final_fit,
data = pokemon_test,
type = "prob") %>%
mutate(type_1 = as.factor(type_1)) %>%
roc_auc(truth = type_1, .pred_Bug:.pred_Water)
library(pROC)
# pruned tree
best1 <- select_best(tune_res)
class_tree_final <- finalize_workflow(tree_workflow, best1)
class_tree_final_fit <- fit(class_tree_final, data = pokemon_test)
# random forest
best2 <- select_best(tune_res_forest)
rand_tree_final <- finalize_workflow(forest_workflow, best2)
rf_fit <- fit(rand_tree_final, data = pokemon_test)
# boosted tree
best3 <- select_best(tune_res_boost)
rand_tree_final <- finalize_workflow(boost_workflow, best3)
boost_fit <- fit(rand_tree_final, data = pokemon_test)
# auc values
# ROC curve
# roc_auc
deci_tree_fit <- augment(class_tree_final_fit,
new_data = pokemon_test,
type = "prob") %>%
mutate(type_1 = as.factor(type_1)) %>%
roc_auc(truth = type_1, .pred_Bug:.pred_Water)
rand_tree_fit <- augment(rf_fit,
new_data = pokemon_test,
type = "prob") %>%
mutate(type_1 = as.factor(type_1)) %>%
roc_auc(truth = type_1, .pred_Bug:.pred_Water)
boost_model_fit <- augment(boost_fit,
new_data = pokemon_test,
type = "prob") %>%
mutate(type_1 = as.factor(type_1)) %>%
roc_auc(truth = type_1, .pred_Bug:.pred_Water)
matrix_rocauc <- bind_rows("ROC_AUC for the Best pruned tree model"= deci_tree_fit,"ROC_AUC for the Best Random Forest model"=rand_tree_fit,"ROC_AUC for the Best Boosted model"=boost_model_fit,.id="model")
matrix_rocauc
knitr::opts_chunk$set(echo = TRUE, message = FALSE,
warning = FALSE)
library(tidyverse)
library(tidymodels)
library(ISLR)
library(vip)
library(janitor)
library(randomForest)
library(xgboost)
library(ggplot2)
library(corrr)
# Reading the data , tidying the data and setting the recipe as in homework-2
abalone <- read.csv("/Users/xuao/Documents/2022Fall/Pstat131/PSTAT231/homework-6/data/abalone.csv")
abalone$age <- abalone$ring+1.5
set.seed(1888)
abalone_not_ring <- subset(abalone, select = -c(rings))
split <- initial_split(abalone_not_ring, prop = 0.8,strata = diameter)
abalone_train <- training(split)
abalone_test <- testing(split)
abalone_folds <- vfold_cv(abalone_train,v=5)
cat_dummy <- recipe(age ~ ., data = abalone_train) %>%
step_dummy(all_nominal_predictors(),-all_outcomes()) %>%
step_normalize(all_predictors()) %>%
step_interact(terms = ~ starts_with("type"):shucked_weight) %>%
step_interact(terms = ~ longest_shell:diameter) %>%
step_interact(terms = ~ shucked_weight:shell_weight)
# Setting up the random forest workflow
abalone_bagging_spec <- rand_forest(mtry = .cols()) %>%
set_engine("ranger", importance = "impurity") %>%
set_mode("regression") %>%
set_args(mtry = tune(),trees = tune(), min_n = tune())
abalone_rand_tree_wf <- workflow() %>%
add_recipe(cat_dummy) %>%
add_model(abalone_bagging_spec)
# set up grid
abalone_grid <- grid_regular(mtry(range = c(1, 8)),trees(range = c(0, 8)), min_n(range = c(0, 4)),levels = 8)
# tuning
abalone_tune_res_rand <- tune_grid(
object = abalone_rand_tree_wf,
resamples = abalone_fold,
grid = abalone_grid ,
metrics = metric_set(... = rmse)
)
# Reading the data , tidying the data and setting the recipe as in homework-2
abalone <- read.csv("/Users/xuao/Documents/2022Fall/Pstat131/PSTAT231/homework-6/data/abalone.csv")
abalone$age <- abalone$ring+1.5
set.seed(1888)
abalone_not_ring <- subset(abalone, select = -c(rings))
split <- initial_split(abalone_not_ring, prop = 0.8,strata = diameter)
abalone_train <- training(split)
abalone_test <- testing(split)
abalone_folds <- vfold_cv(abalone_train,v=5)
cat_dummy <- recipe(age ~ ., data = abalone_train) %>%
step_dummy(all_nominal_predictors(),-all_outcomes()) %>%
step_normalize(all_predictors()) %>%
step_interact(terms = ~ starts_with("type"):shucked_weight) %>%
step_interact(terms = ~ longest_shell:diameter) %>%
step_interact(terms = ~ shucked_weight:shell_weight)
# Setting up the random forest workflow
abalone_bagging_spec <- rand_forest(mtry = .cols()) %>%
set_engine("ranger", importance = "impurity") %>%
set_mode("regression") %>%
set_args(mtry = tune(),trees = tune(), min_n = tune())
abalone_rand_tree_wf <- workflow() %>%
add_recipe(cat_dummy) %>%
add_model(abalone_bagging_spec)
# set up grid
abalone_grid <- grid_regular(mtry(range = c(1, 8)),trees(range = c(0, 8)), min_n(range = c(0, 4)),levels = 8)
# tuning
abalone_tune_res_rand <- tune_grid(
object = abalone_rand_tree_wf,
resamples = abalone_folds,
grid = abalone_grid ,
metrics = metric_set(... = rmse)
)
best_metricc <- select_best(abalone_tune_res_rand)
abalone_rand_tree_final <- finalize_workflow(abalone_rand_tree_wf, best_metricc)
abalone_fit <- fit(abalone_rand_tree_final, data = abalone_training)
abalone_metrics <- metric_set(rmse, rsq, mae)
abalone_test_predict <- predict(abalone_fit,abalone_testing %>% select(-age))
# Reading the data , tidying the data and setting the recipe as in homework-2
abalone <- read.csv("/Users/xuao/Documents/2022Fall/Pstat131/PSTAT231/homework-6/data/abalone.csv")
abalone$age <- abalone$ring+1.5
set.seed(1888)
abalone_not_ring <- subset(abalone, select = -c(rings))
split <- initial_split(abalone_not_ring, prop = 0.8,strata = diameter)
abalone_train <- training(split)
abalone_test <- testing(split)
abalone_folds <- vfold_cv(abalone_train,v=5)
cat_dummy <- recipe(age ~ ., data = abalone_train) %>%
step_dummy(all_nominal_predictors(),-all_outcomes()) %>%
step_normalize(all_predictors()) %>%
step_interact(terms = ~ starts_with("type"):shucked_weight) %>%
step_interact(terms = ~ longest_shell:diameter) %>%
step_interact(terms = ~ shucked_weight:shell_weight)
# Setting up the random forest workflow
abalone_bagging_spec <- rand_forest(mtry = .cols()) %>%
set_engine("ranger", importance = "impurity") %>%
set_mode("regression") %>%
set_args(mtry = tune(),trees = tune(), min_n = tune())
abalone_rand_tree_wf <- workflow() %>%
add_recipe(cat_dummy) %>%
add_model(abalone_bagging_spec)
abalone_grid <- grid_regular(mtry(range = c(1, 8)),trees(range = c(0, 8)), min_n(range = c(0, 4)),levels = 8)
# Set up tuning
abalone_tune_res_rand <- tune_grid(
object = abalone_rand_tree_wf,
resamples = abalone_folds,
grid = abalone_grid ,
metrics = metric_set(... = rmse)
)
best <- select_best(abalone_tune_res_rand)
abalone_rand_tree_final <- finalize_workflow(abalone_rand_tree_wf, best)
abalone_fit <- fit(abalone_rand_tree_final, data = abalone_training)
abalone_metrics <- metric_set(rmse, rsq, mae)
abalone_test_predict <- predict(abalone_fit,abalone_test %>% select(-age))
#abalone_train_res and test
abalone_test_res <- bind_cols(abalone_test_predict, abalone_test %>% select(age))
abalone_metrics(abalone_test_res, truth = age, estimate = .pred)
library(pROC)
# pruned tree
tree_final <- finalize_workflow(tree_workflow, best1)
knitr::opts_chunk$set(echo = TRUE, message = FALSE,
warning = FALSE)
rm(list = ls())
library(tidyverse)
library(tidymodels)
library(ISLR)
library(vip)
library(janitor)
library(randomForest)
library(xgboost)
library(ggplot2)
library(corrr)
pokemon<-read.csv("/Users/xuao/Documents/2022Fall/Pstat131/PSTAT231/homework-6/data/Pokemon.csv")
pokemon<-clean_names(pokemon)
pokemon<-pokemon %>%
filter(type_1 %in% c("Bug","Fire","Grass","Normal","Water","Psychic"))
pokemon$type_1<-factor(pokemon$type_1)
pokemon$legendary<-factor(pokemon$legendary)
pokemon_split <- initial_split(pokemon, prop = 0.80, strata = type_1)
pokemon_train <- training(pokemon_split)
pokemon_test <- testing(pokemon_split)
pokemon_folds <- vfold_cv(pokemon_train, v = 5, strata=type_1)
pokemon_recipe <- recipe(type_1 ~ legendary + generation + sp_atk + attack + speed + defense + hp + sp_def,
data = pokemon_train) %>%
step_dummy(legendary,generation) %>%
step_center(all_predictors()) %>%
step_scale(all_predictors())
library(corrplot)
cor_pokemon_train <- pokemon_train %>%
select(where(is.numeric)) %>%
cor(use = "pairwise.complete.obs", method = "pearson")
corrplot.mixed(cor_pokemon_train)
tree_spec<-decision_tree() %>%
set_engine("rpart")
class_tree_spec<-tree_spec %>%
set_mode("classification")
tree_workflow <-workflow() %>%
add_model(class_tree_spec %>% set_args(cost_complexity=tune())) %>%
add_recipe(pokemon_recipe)
set.seed(2888)
pokemon_folds <- vfold_cv(pokemon_train)
param_grid <- grid_regular(cost_complexity(range = c(-3, -1)),levels=10)
tune_res <- tune_grid(
tree_workflow,
resamples=pokemon_folds,
grid=param_grid,
metrics=metric_set(roc_auc)
)
autoplot(tune_res)
collect_metrics(tune_res)
arrange(tune_res)
best1 <- select_best(tune_res)
best1
library(rpart.plot)
class_tree_final <- finalize_workflow(tree_workflow,best1)
class_tree_final_fit<-fit(class_tree_final,data=pokemon_train)
class_tree_final_fit %>%
extract_fit_engine() %>%
rpart.plot()
forest <- rand_forest() %>%
set_engine("ranger", importance="impurity") %>%
set_mode("classification") %>%
set_args(mtry = tune(),trees = tune(), min_n = tune())
forest
forest_workflow <- workflow() %>%
add_model(forest %>% set_args(mtry = tune(), trees = tune(),
min_n = tune())) %>%
add_recipe(pokemon_recipe)
#forest_workflow
param_grid2<-grid_regular(mtry(range = c(1, 8)),
trees(range = c(1,8)),
min_n(range = c(1,8)),
levels = 8)
param_grid2
#install.packages("ranger")
tune_res_forest<-tune_grid(
forest_workflow,
resamples = pokemon_folds,
grid = param_grid2,
metrics = metric_set(roc_auc)
)
autoplot(tune_res_forest)
collect_metrics(tune_res_forest) %>%
arrange(desc(mean))
best2<-select_best(tune_res_forest)
best2
class_tree_final_fit %>%
pull_workflow_fit() %>%
vip()
boost_spec <- boost_tree(trees = c(10,2000), tree_depth = 4) %>%
set_engine("xgboost") %>%
set_mode("classification")
param_grid_boost <- grid_regular(trees(range = c(10, 2000)),  levels = 10)
boost_workflow <- workflow() %>%
add_model(boost_spec %>% set_args(trees = tune())) %>%
add_recipe(pokemon_recipe)
tune_res_boost <- tune_grid(
boost_workflow,
resamples = pokemon_folds,
grid = param_grid_boost,
metrics = metric_set(roc_auc)
)
autoplot(tune_res_boost)
collect_metrics(tune_res_boost)
arrange(tune_res_boost)
best3<-select_best(tune_res_boost)
best3
library(pROC)
# pruned tree
tree_final <- finalize_workflow(tree_workflow, best1)
tree_final_fit <- fit(class_tree_final, data = pokemon_test)
# random forest
random_forest_tree_final <- finalize_workflow(forest_workflow, best2)
rf_fit <- fit(random_forest_tree_final, data = pokemon_test)
# boosted tree
rand_tree_final <- finalize_workflow(boost_workflow, best3)
boost_fit <- fit(rand_tree_final, data = pokemon_test)
# auc and ROC curve
# roc_auc
tree_fit <- augment(tree_final_fit,
new_data = pokemon_test,
type = "prob") %>%
mutate(type_1 = as.factor(type_1)) %>%
roc_auc(truth = type_1, .pred_Bug:.pred_Water)
rand_tree_fit <- augment(rf_fit,
new_data = pokemon_test,
type = "prob") %>%
mutate(type_1 = as.factor(type_1)) %>%
roc_auc(truth = type_1, .pred_Bug:.pred_Water)
boost_model_fit <- augment(boost_fit,
new_data = pokemon_test,
type = "prob") %>%
mutate(type_1 = as.factor(type_1)) %>%
roc_auc(truth = type_1, .pred_Bug:.pred_Water)
matrix_rocauc <- bind_rows("ROC_AUC for the Best pruned tree model"= tree_fit,"ROC_AUC for the Best Random Forest model"=rand_tree_fit,"ROC_AUC for the Best Boosted model"=boost_model_fit,.id="model")
matrix_rocauc
# Reading the data, tidying the data and setting the recipe as in homework-2
abalone <- read.csv("/Users/xuao/Documents/2022Fall/Pstat131/PSTAT231/homework-6/data/abalone.csv")
abalone$age <- abalone$ring+1.5
set.seed(1888)
abalone_not_ring <- subset(abalone, select = -c(rings))
split <- initial_split(abalone_not_ring, prop = 0.8,strata = diameter)
abalone_train <- training(split)
abalone_test <- testing(split)
abalone_folds <- vfold_cv(abalone_train,v=5)
cat_dummy <- recipe(age ~ ., data = abalone_train) %>%
step_dummy(all_nominal_predictors(),-all_outcomes()) %>%
step_normalize(all_predictors()) %>%
step_interact(terms = ~ starts_with("type"):shucked_weight) %>%
step_interact(terms = ~ longest_shell:diameter) %>%
step_interact(terms = ~ shucked_weight:shell_weight)
# Setting up the random forest workflow
abalone_bagging_spec <- rand_forest(mtry = .cols()) %>%
set_engine("ranger", importance = "impurity") %>%
set_mode("regression") %>%
set_args(mtry = tune(),trees = tune(), min_n = tune())
abalone_rand_tree_wf <- workflow() %>%
add_recipe(cat_dummy) %>%
add_model(abalone_bagging_spec)
abalone_grid <- grid_regular(mtry(range = c(1, 8)),trees(range = c(0, 8)), min_n(range = c(0, 4)),levels = 8)
# Set up tuning
abalone_tune_res_rand <- tune_grid(
object = abalone_rand_tree_wf,
resamples = abalone_folds,
grid = abalone_grid ,
metrics = metric_set(... = rmse)
)
best <- select_best(abalone_tune_res_rand)
abalone_rand_tree_final <- finalize_workflow(abalone_rand_tree_wf, best)
abalone_fit <- fit(abalone_rand_tree_final, data = abalone_training)
# Reading the data, tidying the data and setting the recipe as in homework-2
abalone <- read.csv("/Users/xuao/Documents/2022Fall/Pstat131/PSTAT231/homework-6/data/abalone.csv")
abalone$age <- abalone$ring+1.5
set.seed(1888)
abalone_not_ring <- subset(abalone, select = -c(rings))
split <- initial_split(abalone_not_ring, prop = 0.8,strata = diameter)
abalone_train <- training(split)
abalone_test <- testing(split)
abalone_folds <- vfold_cv(abalone_train,v=5)
cat_dummy <- recipe(age ~ ., data = abalone_train) %>%
step_dummy(all_nominal_predictors(),-all_outcomes()) %>%
step_normalize(all_predictors()) %>%
step_interact(terms = ~ starts_with("type"):shucked_weight) %>%
step_interact(terms = ~ longest_shell:diameter) %>%
step_interact(terms = ~ shucked_weight:shell_weight)
# Setting up the random forest workflow
abalone_bagging_spec <- rand_forest(mtry = .cols()) %>%
set_engine("ranger", importance = "impurity") %>%
set_mode("regression") %>%
set_args(mtry = tune(),trees = tune(), min_n = tune())
abalone_rand_tree_wf <- workflow() %>%
add_recipe(cat_dummy) %>%
add_model(abalone_bagging_spec)
abalone_grid <- grid_regular(mtry(range = c(1, 8)),trees(range = c(0, 8)), min_n(range = c(0, 4)),levels = 8)
# Set up tuning
abalone_tune_res_rand <- tune_grid(
object = abalone_rand_tree_wf,
resamples = abalone_folds,
grid = abalone_grid ,
metrics = metric_set(... = rmse)
)
best <- select_best(abalone_tune_res_rand)
abalone_rand_tree_final <- finalize_workflow(abalone_rand_tree_wf, best)
abalone_fit <- fit(abalone_rand_tree_final, data = abalone_train)
abalone_metrics <- metric_set(rmse, rsq, mae)
abalone_test_predict <- predict(abalone_fit,abalone_test %>% select(-age))
#abalone_train_res and test
abalone_test_res <- bind_cols(abalone_test_predict, abalone_test %>% select(age))
abalone_metrics(abalone_test_res, truth = age, estimate = .pred)
