knitr::opts_chunk$set(echo = TRUE, message = FALSE,
warning = FALSE)
mpg %>%
summarise(avg_hwy = mean(hwy))
knitr::opts_chunk$set(echo = TRUE, message = FALSE,
warning = FALSE)
mean(c(1, 2, 3))
# ?mean
# help(mean)
# This is a code chunk!
# Any uncommented text in here will be run as R code.
# For example:
x <- seq(1, 10, 1)
x
# install.packages("tidyverse")
# install.packages("tidymodels")
# install.packages("ISLR")
library(tidyverse)
library(tidymodels)
library(ISLR)
mpg
mpg %>%
filter(class == "compact" & manufacturer == "audi")
filtered_mpg <- mpg %>%
filter(class == "compact" & manufacturer == "audi")
mpg_small <- mpg %>%
select(year, hwy, class)
mpg %>% select(year:class) %>%
head()
mpg %>% select(-(year:class)) %>%
head()
mpg %>%
mutate(after_2k = if_else(year <= 2000, 0, 1)) %>%
select(after_2k, year, everything()) %>%
head()
transmute(mpg,
after_2k = if_else(year <= 2000, 0, 1)) %>%
head()
mpg %>%
summarise(avg_hwy = mean(hwy))
mpg %>%
group_by(class) %>%
summarise(avg_hwy = mean(hwy)) %>%
arrange(avg_hwy)
mpg %>%
group_by(manufacturer) %>%
summarise(avg_hwy = mean(hwy)) %>%
arrange(avg_hwy)
knitr::opts_chunk$set(echo = TRUE, message = FALSE,
warning = FALSE)
knitr::opts_chunk$set(echo = TRUE, message = FALSE,
warning = FALSE)
library(ggplot2)
library(tidyverse)
library(tidymodels)
library(corrplot)
library(ggthemes)
tidymodels_prefer()
diamonds %>%
head()
diamonds %>%
select(is.numeric) %>%
cor() %>%
corrplot(type = 'lower', diag = FALSE,
method = 'color')
diamonds %>%
ggplot(aes(x = price, y = reorder(cut, price), fill = color)) +
geom_boxplot() +
labs(y = "Cut", x = "Price") +
theme_bw()
library(tidyverse)
library(tidymodels)
knitr::opts_chunk$set(echo = TRUE, message = FALSE,
warning = FALSE)
library(tidyverse)
library(tidymodels)
library(tidyverse)
library(tidymodels)
knitr::opts_chunk$set(echo = TRUE, message = FALSE,
warning = FALSE)
diamonds %>%
head()
diamonds %>%
ggplot(aes(x = carat, y = reorder(color, carat))) +
geom_boxplot() +
theme_bw() +
labs(x = "Carat", y = "Color")
diamonds %>%
ggplot(aes(x = price)) +
geom_histogram(bins = 60) +
theme_bw()
set.seed(3435)
diamonds_split <- initial_split(diamonds, prop = 0.80,
strata = price)
diamonds_train <- training(diamonds_split)
diamonds_test <- testing(diamonds_split)
set.seed(3435)
diamonds_split <- initial_split(diamonds, prop = 0.80,
strata = price)
diamonds_train <- training(diamonds_split)
diamonds_test <- testing(diamonds_split)
diamonds_recipe <- recipe(price ~ ., data = diamonds_train) %>%
step_dummy(all_nominal_predictors())
lm_model <- linear_reg() %>%
set_engine("lm")
lm_wflow <- workflow() %>%
add_model(lm_model) %>%
add_recipe(diamonds_recipe)
lm_fit <- fit(lm_wflow, diamonds_train)
lm_fit %>%
# This returns the parsnip object:
extract_fit_parsnip() %>%
# Now tidy the linear model object:
tidy()
diamond_train_res <- predict(lm_fit, new_data = diamonds_train %>% select(-price))
diamond_train_res %>%
head()
diamond_train_res <- bind_cols(diamond_train_res, diamonds_train %>% select(price))
diamond_train_res %>%
head()
diamond_train_res %>%
ggplot(aes(x = .pred, y = price)) +
geom_point(alpha = 0.2) +
geom_abline(lty = 2) +
theme_bw() +
coord_obs_pred()
rmse(diamond_train_res, truth = price, estimate = .pred)
diamond_metrics <- metric_set(rmse, rsq, mae)
diamond_metrics(diamond_train_res, truth = price,
estimate = .pred)
knitr::opts_chunk$set(echo = TRUE, message = FALSE,
warning = FALSE)
cor_Smarket <- Smarket %>%
select(-Direction) %>%
correlate()
knitr::opts_chunk$set(echo = TRUE, message = FALSE,
warning = FALSE)
knitr::opts_chunk$set(echo = TRUE, message = FALSE,
warning = FALSE)
library(tidymodels)
library(ISLR) # For the Smarket data set
library(ISLR2) # For the Bikeshare data set
library(discrim)
library(poissonreg)
library(corrr)
library(klaR) # for naive bayes
tidymodels_prefer()
cor_Smarket <- Smarket %>%
select(-Direction) %>%
correlate()
rplot(cor_Smarket)
cor_Smarket %>%
stretch() %>%
ggplot(aes(x, y, fill = r)) +
geom_tile() +
geom_text(aes(label = as.character(fashion(r))))
ggplot(Smarket, aes(factor(Year), Volume)) +
geom_boxplot() +
geom_jitter(alpha = 0.1) +
xlab("Year")
Smarket %>%
ggplot(aes(x = Direction)) +
geom_bar()
set.seed(3435)
smarket_split <- initial_split(Smarket, prop = 0.70,
strata = Direction)
smarket_train <- training(smarket_split)
smarket_test <- testing(smarket_split)
smarket_recipe <- recipe(Direction ~ Lag1 + Lag2 + Lag3 + Lag4 +
Lag5 + Volume, data = smarket_train)
log_reg <- logistic_reg() %>%
set_engine("glm") %>%
set_mode("classification")
log_wkflow <- workflow() %>%
add_model(log_reg) %>%
add_recipe(smarket_recipe)
log_fit <- fit(log_wkflow, smarket_train)
log_fit %>%
tidy()
predict(log_fit, new_data = smarket_train, type = "prob")
augment(log_fit, new_data = smarket_train) %>%
conf_mat(truth = Direction, estimate = .pred_class)
augment(log_fit, new_data = smarket_train) %>%
conf_mat(truth = Direction, estimate = .pred_class) %>%
autoplot(type = "heatmap")
log_reg_acc <- augment(log_fit, new_data = smarket_train) %>%
accuracy(truth = Direction, estimate = .pred_class)
log_reg_acc
lda_mod <- discrim_linear() %>%
set_mode("classification") %>%
set_engine("MASS")
lda_wkflow <- workflow() %>%
add_model(lda_mod) %>%
add_recipe(smarket_recipe)
lda_fit <- fit(lda_wkflow, smarket_train)
predict(lda_fit, new_data = smarket_train, type = "prob")
augment(lda_fit, new_data = smarket_train) %>%
conf_mat(truth = Direction, estimate = .pred_class)
lda_acc <- augment(lda_fit, new_data = smarket_train) %>%
accuracy(truth = Direction, estimate = .pred_class)
lda_acc
qda_mod <- discrim_quad() %>%
set_mode("classification") %>%
set_engine("MASS")
qda_wkflow <- workflow() %>%
add_model(qda_mod) %>%
add_recipe(smarket_recipe)
qda_fit <- fit(qda_wkflow, smarket_train)
predict(qda_fit, new_data = smarket_train, type = "prob")
augment(qda_fit, new_data = smarket_train) %>%
conf_mat(truth = Direction, estimate = .pred_class)
qda_acc <- augment(qda_fit, new_data = smarket_train) %>%
accuracy(truth = Direction, estimate = .pred_class)
qda_acc
nb_mod <- naive_Bayes() %>%
set_mode("classification") %>%
set_engine("klaR") %>%
set_args(usekernel = FALSE)
nb_wkflow <- workflow() %>%
add_model(nb_mod) %>%
add_recipe(smarket_recipe)
nb_fit <- fit(nb_wkflow, smarket_train)
predict(nb_fit, new_data = smarket_train, type = "prob")
augment(nb_fit, new_data = smarket_train) %>%
conf_mat(truth = Direction, estimate = .pred_class)
nb_acc <- augment(nb_fit, new_data = smarket_train) %>%
accuracy(truth = Direction, estimate = .pred_class)
nb_acc
accuracies <- c(log_reg_acc$.estimate, lda_acc$.estimate,
nb_acc$.estimate, qda_acc$.estimate)
models <- c("Logistic Regression", "LDA", "Naive Bayes", "QDA")
results <- tibble(accuracies = accuracies, models = models)
results %>%
arrange(-accuracies)
predict(nb_fit, new_data = smarket_test, type = "prob")
augment(nb_fit, new_data = smarket_test) %>%
conf_mat(truth = Direction, estimate = .pred_class)
multi_metric <- metric_set(accuracy, sensitivity, specificity)
augment(nb_fit, new_data = smarket_test) %>%
multi_metric(truth = Direction, estimate = .pred_class)
augment(nb_fit, new_data = smarket_test) %>%
roc_curve(Direction, .pred_Down) %>%
autoplot()
set.seed(3435)
smarket_split <- initial_split(Smarket, prop = 0.70,
strata = Direction)
smarket_train <- training(smarket_split)
smarket_test <- testing(smarket_split)
smarket_recipe <- recipe(Direction ~ Lag1 + Lag2 + Lag3 + Lag4 +
Lag5 + Volume, data = smarket_train)
multi_metric <- metric_set(accuracy, sensitivity, specificity)
augment(nb_fit, new_data = smarket_test) %>%
multi_metric(truth = Direction, estimate = .pred_class)
